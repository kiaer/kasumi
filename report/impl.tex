\chapter{Implementation}
\label{ch:impl}
\section{KASUMI Cipher}
\subsection{Implementation}

See appendix \ref{sec:inst} for testing of the KASUMI cipher implementation.

The implemenation of the KASUMI follows the theory described in the
chapter \nameref{ch:kas}.

\subsection{Benchmarks and Performance}
The benchmarks of the KASUMI cipher implemented is performed on two
laptops. The Laptops will each compute the encryption on 64-bit of
data 10.000.000 times. An average time of ten runs of this test is
chosen as the result. Both machines run on Intels Hashwell
architecture with Core i7 CPUs. The specifications of the laptops are as follows:
\begin{table}[h!]
    \begin{tabular}{l|l|l}
                                    & Zenbook - i7           & Yoga
                                                               pro 2 -
      i7\\ \hline
    CPU Frequency                   & 1,8 GHZ @ 2.9ghz TURBO & 2,0 GHZ @ 3.0ghz TURBO \\ \hline
    CPU Cycles/s                    & 2900000000             & 3000000000             \\ \hline
    Times encryption of 64 bit data & 10000000               & 10000000               \\ \hline
    Total bit encyrpted             & 640000000              & 640000000              \\
    \end{tabular}
    \caption{CPU Specs of laptops performing benchmarks}
    \label{tab:specs}
\end{table}\\
The tests will be performed with the
GCC-compiler \footnote{The Gnu Compiler Collection -
  https://gcc.gnu.org/}. They will be performed with different compile
flags for optimization, consisting of no flags, O2, O3 and Ofast as
these are the most common flags for optimization. The two tables
\ref{tab:zen} and \ref{tab:yoga} will show the results of the KASUMI
tests.
\begin{table}[h!]
    \begin{tabular}{l|l|l|l|l}
     Zenbook 1.8 ghz.  & ~                     & ~             & ~              & ~               \\
    GCC compile flags. & Time in sec (average) & Cycles in tot & Cycles per bit & Cycles per byte \\ \hline
    None               & 7,2322                & 20973380000   & 32,77090625    & 262,16725       \\ \hline
    O2                 & 2,0035                & 5810150000    & 9,078359375    & 72,626875       \\ \hline
    O3                 & 1,8945                & 5494050000    & 8,584453125    & 68,675625       \\ \hline
    Ofast              & 1,897                 & 5501300000    & 8,59578125     & 68,76625        \\
    \end{tabular}
    \caption{Zenbook i7 benchmarks}
    \label{tab:zen}
\end{table}
\begin{table}[h!]
    \begin{tabular}{l|l|l|l|l}
     Yoga 2 pro 2.0 ghz. & ~                     & ~             & ~              & ~               \\
    GCC compile flags.   & Time in sec (average) & Cycles in tot & Cycles per bit & Cycles per byte \\ \hline
    None                 & 6,885                 & 20655000000   & 32,2734375     & 258,1875        \\ \hline
    O2                   & 1,933636364           & 5800909091    & 9,063920455    & 72,51136364     \\ \hline
    O3                   & 1,823333333           & 5470000000    & 8,546875       & 68,375          \\ \hline
    Ofast                & 1,835                 & 5505000000    & 8,6015625      & 68,8125         \\
    \end{tabular}
    \caption{Yoga 2 i7 benchmarks}
    \label{tab:yoga}
\end{table}\\


For analysis of the performance of the cipher, gprof \footnote{GNU
  Profiler - https://sourceware.org/binutils/docs/gprof/} is used to
analyze each function and get a clear idea of which functions might
cause slowdowns. The following output is produced from running the
tests and analyzing with gprof:
\begin{lstlisting}[caption=Gprof output,captionpos=b,label=lst:grpof]
    %   cumulative   self              self     total
 time   seconds   seconds    calls  ns/call  ns/call  name
 38.56      0.53     0.53 240000024     2.20     2.20  fi
 23.50      0.85     0.32                             keyschedule
 18.36      1.10     0.25 80000008     3.14     9.75  fo
 12.49      1.27     0.17 80000008     2.14     2.14  fl
  4.41      1.33     0.06                             kasumi_enc
\end{lstlisting}
Note that for getting an somewhat accurate representation of the time usage of
each function, the functions of the cipher cannot be inlined. Thus the
attribute \textit{noinline} must be included for each function. This
takes away some of the optimzations done by the Ofast compile
flag. Not supringsingly it shows that \textit{fi} and
\textit{keyschedule} takes up the most computational
power. Since \textit{fi} requires lookups in a predefined table for every computation, this
could be seen as expected. As for the keyschedule, it's recalculated
in each encryption and therefore will require a new computation in
each new encryption done.

If we consider the results of \ref{lst:grpof} and look at both
\ref{tab:zen} and \ref{tab:yoga}, this shows us that for each byte
encrypted around 17 cycles of the CPU is used on generating the
keyschedule. That leaves around 50 cylces remaining for the actual
encryption of a text.

Since most of the actual computations TODO assembly vs C? Find kilder?

Further optimization could be gained by using a different compiler. As
both test machines contain Intels i7 CPUs, noticeable performance
increases could be gained by using a Intel compiler. Tests with the
Intel compiler has not been performed. Kilder?


\section{TMTO-Attack}

See appendix \ref{sec:inst} for installation of the TMTO attack.

The TMTO-attack follows the theory of a Rainbow Table attack as
described in Section \ref{sec:raintheory}.

The TMTO-attack is implemented as a 64-bit attack, and for testing
purpose a 32-bit version of the attack is also implemented.

\subsection{Tablegenerator}
There are two different tablegenerators one for our 32bit implementation and one for our 64 bit.
The 32bit implementation consists of one function: tableGenerator32. This function takes an uint32\_t which is the text that the table is generated from. The implementation is quite simple, it consists of two for loops where one is nested into the other. The first for loop initializes the start points of the table these are generated from using MD5 on the iterator of the start point this is repeated $m$ times.
The SP is then used in the second for loop to generate the chain for the rainbow table.
The keyscheduler is applied to the key, then the encryption of the text happens. The new ciphertext then gets the reduciton function applied to it. Now the first chain link has been created this is done $t$ times and the final point the end point is stored in a binary file.
The endpoints are stored in a binary file, the first 8 byte of the endpoint key is stored. This happens with fopen, fwrite and fclose.
\lstset{language=C}
\begin{lstlisting}
  FILE * write_ptr;
  write_ptr = fopen("table32bits.bin", "wb");
  fwrite(ep,sizeof(ep),1,write_ptr);
  fclose(write_ptr);
\end{lstlisting}
The implementation of the 64 bit table has not been tested and it is mostly a question of scaling the 32 bit implementation. The reduction function will also be changed since the 32bit table generator uses a 32bit reduction function.
\begin{lstlisting}
uint64_t reduction64(int n, uint16_t * tempkey){
    uint64_t key;
    uint32_t key1;
    uint32_t key2;
    key1 = (tempkey[0]+n) << 16 | (tempkey[1]+n);
    key2 = (tempkey[2]+n) << 16 | (tempkey[3]+n);
    key =  (uint64_t) key1 << 32 | key2;
    return key;
}
\end{lstlisting}

The reduction function takes an integer, and the current key. The integer is at what position in the chain has been reached. The key is given as an $uint16\_t$ array, each element in the array has n added to it and it is shifted into a $uint64\_t$ which is returned as the reduced function.

\subsection{Online Phase}
The online phase is implemented the same way as described in \cite{176}. Given the ciphertext and the corresponding text we calculate the key used for the encryption. The initial step is to give the online phase the text and the ciphertext. From the ciphertext certain points are computed which will be checked with the rainbow table:
\begin{lstlisting}
 ep[0] = reduction32((chainLength-1), ciphertext);
    temp = ciphertext;
    for (t = (chainLength-2); t >= 0; t--){
        for(i=0;i<4;i++)
            temp2[i] = ciphertext[i];
        temp=temp2;
        for(j = t; j < chainLength; j++){
            if(j == (chainLength-1)){
                ep[chainLength-1-t] = reduction32(j, temp);
            } else{
                tp = reduction32(j,temp);
                temp[0] = tp >> 16;
                temp[1] = tp;
                for(i = 0; i < 8; i++){
                    key[i] = temp[i%2];
                }
                keyschedule(key);
                temp = kasumi_enc(text);
            }
        }
    }
\end{lstlisting}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "Thesis"
%%% End:

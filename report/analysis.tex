\chapter{Analysis}
\label{ch:anal}

\section{TMTO Attack}
As the keysize of an attack on the KASUMI cipher used in the 2G
network is \code{64-bit}, we have to perform our tests on a scaled down
key. With the hardware at our disposal the computation of a table
required to perform the attack on a \code{64-bit} key would simply be
unrealistic. Therefore all of our testing is done on tables generated
with \code{32-bit} keys. We use the same idea as the scaling from \code{128-bit} to
\code{64-bit} discussed in chapter \ref{ch:kas}.

Thus a key $K$ built from a \code{32-bit} $K_{32} = K_1 || K_2$  implementation will
look as follows
\[K = K_1 || K_2 || K_1 || K_2 || K_1 || K_2 || K_1 || K_2\]
As to gain an idea of how our implementation matches up with
the math and parameter choices done in chapter \ref{ch:param}, we have to generate
information on an actual attack on a \code{32-bit} key. If the \code{32-bit} test
results match with our calculations, we can begin to give estimates
on hthe actual attack(\code{64-bit} keysize).
\subsection{Pre-computational phase}
To test the table generation we will first set some parameters
valid for \code{32-bit} testing.

Using the same parameter setup as described in \ref{sec:rainbowparam}
table \ref{tab:rainparam32} gives us valid parameter choices. For the
testing of \code{32-bit} no boundaries were set.
\begin{table}[H]
  \centering
  \text{\texttt{Success{ }={ }0.730000,{ }Rmsc{ }={ }1.849002,{ }l{ }={ }1,{ }Offline{ }phase{ }={ }2{\char`\^}32.886747}}
  \begin{tabular}{llll}
    m & t & M(MB) & T \\ \hline
    $2^{25.00}$ & $2^{7.89}$ & $134.22$ & $2^{13.67}$ \\
    $2^{25.50}$ & $2^{7.39}$ & $189.81$ & $2^{12.71}$ \\
    $2^{26.00}$ & $2^{6.89}$ & $268.44$ & $2^{11.76}$ \\
    $2^{26.50}$ & $2^{6.39}$ & $379.63$ & $2^{10.83}$ \\
    $2^{27.00}$ & $2^{5.89}$ & $536.87$ & $2^{9.92}$ \\
  \end{tabular}
  \caption{Rainbow Parameters - 32-bit keysize}
  \label{tab:rainparam32}
\end{table}
Since we are only testing on \code{32-bit} there is no real concern of
memory usage or online time. For this reason we went with a parameter
choice of $m=2^{25} \approx 33445532$ and $t= 2^{7.89} \approx
236$. The table generator will be tested on the actual
pre-computational time and the memory usage.

\textbf{Pre-computational time}

Table \ref{tab:rainparam32} states that an expected amount of
KASUMI encryptions required for generation of the table is
$2^{32.886}$. Looking back to \ref{sec:benchkas} we know the
amount of time it takes our test machines to perform 10000000 encrytions. As an
example the previously mentioned Zenbook i7 is used. The
Zenbook will perform 10000000 KASUMI encryptions in 1,897
seconds. From this we get an idea of how many encryptions our
machine execute in 1 second.
\[10000000 enc / 1.897 s = 5291005,29 \quad enc/s\]
Now we can calculate the expected running time of the
pre-computational phase
\[2^{32.886} / 5291005.29 \approx 1500s = 25 min \]
Running our implementation with UNIX-command
\code{time}\footnote{\url{https://en.wikipedia.org/wiki/Time_(Unix)}}
allows us to easily check whether or not this matches up. Running the
implementation multiple times resulted in average running time of
approximately 27 minutes. This is $\approx8\%$ more time used than
expected. This can be seen as expected as time is required to write
the table to a disk. Another explanation could be our sequential
approach and the usage of the MD5 algorithm. TODO Some facts to back up maybe?

\textbf{Memory}

We also want to make sure that the actual memory usage matches up with
the expected. From our parameter choice we can see the expected memory
$M_{predicted}=134.22$MB. The previously generated table can easily be
checked to make sure this is correct. Using the UNIX-command
\code{wc}\footnote{\url{https://en.wikipedia.org/wiki/Wc_(Unix)}} with
the \code{-c} flag will allow us to get the byte count of the
generated binary file. Performing this command on our generated table
unsurprisingly gave us a result of
$M_{actual}=134217728\text{B}\approx134.22$MB.

Knowing the time usage and memory usage in the pre-computational phase
matches up with our expected values, we can now give an approximate of
how scaling from a \code{32-bit} keysize to a \code{64-bit} keysize
will look.

Again we take a look back to \ref{sec:rainbowparam}. As we are now
dealing with the actual \code{64-bit} attack the boundaries we set
will now be taken into account again. From the tests on the
\code{32-bit} implementation we saw the size of the table match up
perfectly. Because of this we will not discuss table size further, as
adding additional bit to a binary file should not change the outcome.
Going with the parameters chosen in \ref{sec:rainbowparam} we set
$m=?$ and $t=?$.

From the chosen parameters we know that the pre-computational phase is
estimated to require $2^{64.88}$ encryptions of KASUMI. This amount of encryptions
is infeasible to test on the devices that we ran the
\code{32-bit} implementation on.

TODO Need to ask Andrey about what we can compare with.. HPC clusters?

\subsection{Online phase}

NEED MORE TEST RESULTS

\section{Cost analysis}

Do we want to discuss a machine to compute table?

NEED ONLINE TEST RESULTS TO CREATE AN ACTUAL MACHINE.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "Thesis"
%%% End:
